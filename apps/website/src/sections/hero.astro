---
import { EmptyBackendProvider } from "../components/backend-provider";

const github = "https://github.com/TM9657/flow-like";
const docs = "https://docs.flow-like.com";
const download = "https://github.com/TM9657/flow-like/releases";
---

<section
  class="mx-auto max-w-7xl px-4 pt-8 md:pt-16 lg:pt-16 lg:px-8 pb-12 mt-0 md:mt-8 lg:mt-16"
  data-c2="hsl(0 100% 63% / .10)"
  data-c1="hsl(161 40% 44% / .10)"
>
  <!-- Decorative background -->
  <div aria-hidden="true" class="pointer-events-none absolute inset-0 -z-10">
    <!-- soft grid -->
    <div class="absolute inset-0 opacity-[.12] [mask-image:radial-gradient(55%_55%_at_50%_35%,black,transparent)] bg-[linear-gradient(to_right,theme(colors.muted.DEFAULT/.9)_1px,transparent_1px),linear-gradient(to_bottom,theme(colors.muted.DEFAULT/.9)_1px,transparent_1px)] bg-[size:36px_36px]"></div>
    <!-- color glows -->
    <div class="absolute -top-24 -left-24 h-[420px] w-[420px] rounded-full blur-3xl bg-[conic-gradient(from_210deg_at_50%_50%,theme(colors.emerald.400/.32),transparent_45%)]"></div>
    <div class="absolute -bottom-16 -right-24 h-[420px] w-[420px] rounded-full blur-3xl bg-[conic-gradient(from_30deg_at_50%_50%,theme(colors.primary.DEFAULT/.35),transparent_55%)]"></div>
  </div>

  <div id="hero-cover" class="relative">
    <!-- pins (hidden on small screens for clarity) -->
    <div id="hero-right-pin" class="hidden md:block size-4 bg-primary absolute top-60 -right-1.5 z-10 rounded-full shadow-[0_0_0_4px_rgba(255,255,255,.15)]"></div>
    <div id="hero-left-pin" class="hidden md:block size-4 bg-emerald-500 absolute top-36 -left-1.5 z-10 rounded-full shadow-[0_0_0_4px_rgba(255,255,255,.15)]"></div>
    <div id="hero-right-pin-top" class="hidden md:block size-4 bg-foreground absolute top-12 -right-1.5 z-10 rounded-full"></div>
    <div id="hero-left-pin-top" class="hidden md:block size-4 bg-foreground absolute top-12 -left-1.5 z-10 rounded-full"></div>

    <!-- animated connections -->
    <svg
      id="hero-connections"
      class="pointer-events-none absolute top-0 left-0 hidden md:block"
      style="overflow:hidden"
      aria-hidden="true"
    >
      <path id="hero-right-conn" class="pin-conn text-primary" fill="none"></path>
      <path id="hero-left-conn"  class="pin-conn text-emerald-500" fill="none"></path>
      <path id="hero-right-conn-top" class="pin-conn-solid text-foreground/70" fill="none"></path>
      <path id="hero-left-conn-top"  class="pin-conn-solid text-foreground/70" fill="none"></path>
    </svg>

    <!-- hero card -->
    <div
      class="hero-card relative overflow-hidden rounded-2xl border border-border/80 bg-background/90 backdrop-blur [--ring:theme(colors.primary.DEFAULT/30)] motion-safe:transition-transform motion-safe:duration-300"
      data-tilt
    >
      <!-- subtle vignette and light sweep -->
      <div aria-hidden="true" class="pointer-events-none absolute inset-0">
        <div class="absolute inset-0 bg-gradient-to-tr from-background/70 via-background/30 to-transparent"></div>
        <div class="absolute -inset-0.5 opacity-0 hero-sheen"></div>
      </div>

      <div class="relative grid lg:grid-cols-2 overflow-hidden">
        <!-- copy -->
        <div class="p-6 sm:p-8 md:p-10 space-y-4 motion-safe:opacity-0 motion-safe:translate-y-3 will-change-transform reveal">
          <span
            class="inline-flex items-center gap-2 rounded-full border border-border bg-muted/30 px-3 py-1 text-[11px] font-medium text-muted-foreground"
            >Typed ‚Ä¢ Blazing fast ‚Ä¢ Robust</span
          >
          <h1 class="text-4xl font-extrabold tracking-tight sm:text-5xl leading-[1.05]">
            Typed workflows that <span class="text-primary">scale</span>
          </h1>
          <p class="max-w-2xl text-muted-foreground">
            Design reliable systems with type-safe graphs, Rust-level performance, and built-in governance.
            Start local for a head start, then move to edge or any cloud ‚Äî no rewiring.
          </p>

         <div class="pt-2 flex flex-wrap items-center gap-3">
  <a href={download}
     class="fl-btn bg-primary text-primary-foreground shadow hover:bg-primary/90">
    Download
  </a>
  <a href={docs}
     class="fl-btn border border-border bg-muted text-foreground hover:bg-accent hover:text-accent-foreground">
    Explore docs
  </a>
  <a href={github}
     class="fl-btn border border-primary/30 bg-primary/10 text-primary hover:bg-primary/15">
    Star on GitHub
  </a>
</div>

          <!-- chips -->
          <div class="pt-1 flex flex-wrap items-center gap-2.5 text-sm sm:max-w-xl">
            <span class="fl-chip fl-chip--ghost" data-tint="primary">üß© <b>Type-safe</b> graph contracts</span>
            <span class="fl-chip fl-chip--ghost" data-tint="emerald">üîí Governance & observability</span>
            <span class="fl-chip fl-chip--ghost" data-tint="amber">‚ö° Rust runtime ‚Ä¢ predictable latency</span>
            <span class="fl-chip fl-chip--ghost" data-tint="sky">‚òÅÔ∏è Run local ‚Üí edge ‚Üí cloud</span>
          </div>

          <p class="text-xs text-muted-foreground/90">
            Want AI too? Blend classical ML with GenAI when it helps ‚Äî it‚Äôs one more set of typed nodes, not a separate stack.
          </p>
        </div>

        <!-- live board preview -->
        <div class="relative min-h-[260px] h-full lg:min-h-[420px] motion-safe:opacity-0 will-change-transform reveal">
          <div class="absolute inset-0 bg-gradient-to-tr from-transparent via-background/20 to-background/0"></div>
          <EmptyBackendProvider data="/board.json" client:load />
          <!-- glassy labels overlay (non-blocking) -->
          <div aria-hidden="true" class="pointer-events-none absolute bottom-3 right-3 flex gap-2">
            <span class="fl-glass-tag">Node Graph</span>
            <span class="fl-glass-tag">Live</span>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<style>
  /* Buttons */
  .fl-btn {
    display:inline-flex; align-items:center; gap:.5rem;
    border-radius:1rem; padding:.75rem 1.25rem;
    font-size:.875rem; font-weight:600;
    transition:transform .18s ease, box-shadow .18s ease, background .18s ease, border-color .18s ease;
    will-change:transform;
  }
  .fl-btn--primary {
    background: hsl(var(--primary));
    color: hsl(var(--primary-foreground));
    box-shadow: 0 10px 18px -12px hsl(var(--primary) / .65);
  }
  .fl-btn--primary:hover { transform: translateY(-1px); }
  .fl-btn--muted {
    border:1px solid hsl(var(--border));
    background: hsl(var(--muted));
    color: inherit;
  }
  .fl-btn--muted:hover { background: hsl(var(--accent)); color: hsl(var(--accent-foreground)); }
  .fl-btn--outline {
    border:1px solid hsl(var(--primary) / .35);
    background: hsl(var(--primary) / .08);
    color: hsl(var(--primary));
  }
  .fl-btn--outline:hover { background: hsl(var(--primary) / .15); }

  /* Chips (yours, with hover tuned) */
  .fl-chip { --t: 215 16% 47%;
    display:inline-flex; align-items:center; gap:.5rem;
    padding:.25rem .6rem; border-radius:9999px;
    border:1px solid hsl(var(--t) / .22); background: transparent; color:hsl(var(--t) / .86);
    line-height:1; white-space:nowrap;
    transition:background .15s ease, border-color .15s ease, transform .15s ease, box-shadow .15s ease;
  }
  .fl-chip b { font-weight:600; color:inherit; }
  .fl-chip--ghost:hover { background:hsl(var(--t) / .10); transform:translateY(-1px); box-shadow:0 4px 16px -10px hsl(var(--t) / .45); }
  .fl-chip[data-tint="primary"]{ --t: 0 100% 63%; }
  .fl-chip[data-tint="emerald"]{ --t: 160 84% 40%; }
  .fl-chip[data-tint="amber"]{ --t: 28 96% 54%; }
  .fl-chip[data-tint="sky"]{ --t: 199 89% 48%; }

  /* Glass tags on preview */
  .fl-glass-tag{
    backdrop-filter: blur(6px);
    background: color-mix(in oklab, transparent, hsl(var(--foreground) / .06) 100%);
    border:1px solid hsl(var(--border) / .6);
    color: hsl(var(--muted-foreground));
    font-size:.7rem; padding:.2rem .55rem; border-radius:.7rem;
  }

  /* Card sheen (only when hovering card) */
  .hero-card:hover .hero-sheen{
    background: radial-gradient(120px 120px at var(--mx,50%) var(--my,50%), hsl(var(--primary)/.25), transparent 60%);
    transition: opacity .25s ease;
    opacity: 1;
  }

  /* SVG connections */
  .pin-conn-solid{
    stroke:currentColor; stroke-width:3; stroke-linecap:round; stroke-linejoin:round; vector-effect:non-scaling-stroke;
  }
  .pin-conn{
    stroke:currentColor; stroke-width:4; stroke-linecap:round; stroke-linejoin:round; vector-effect:non-scaling-stroke;
    stroke-dasharray: 8 10;
    animation: flow-dots 1.1s linear infinite;
  }
  @keyframes flow-dots { to { stroke-dashoffset: -18px; } }

  /* Reveal on enter */
  .reveal { opacity: 0; transform: translateY(6px); }
  .reveal.is-visible { opacity: 1; transform: none; transition: opacity .5s ease, transform .5s ease; }

  @media (prefers-reduced-motion: reduce){
    .fl-btn, .fl-chip, .reveal { transition: none !important; transform:none !important; }
    .pin-conn { animation: none !important; }
  }
</style>

<script>
  // helpers
  const $ = (s: string, r = document) => r.querySelector(s);

  const heroEl = document.getElementById("hero-cover");
  const svg = document.getElementById("hero-connections");
  const rp = document.getElementById("hero-right-pin");
  const lp = document.getElementById("hero-left-pin");
  const rpt = document.getElementById("hero-right-pin-top");
  const lpt = document.getElementById("hero-left-pin-top");

  // Make the absolutely-positioned SVG cover the full viewport width
  const setSvgFrame = () => {
    if (!heroEl || !svg) return;
    const r = heroEl.getBoundingClientRect();
    const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    svg.style.left = `${-r.left}px`;
    svg.style.width = `${vw}px`;
    svg.style.height = `${r.height}px`;
    svg.setAttribute("viewBox", `${-r.left} 0 ${vw} ${r.height}`);
    svg.setAttribute("width", String(vw));
    svg.setAttribute("height", String(r.height));
  };

  // Curves: keep endpoints at pin centers, flow to edges
  const bezier = (pin: HTMLElement, isRight: boolean, yOffset = 60) => {
    const hr = heroEl?.getBoundingClientRect() ?? { left:0, top:0, width:0, height:0, right:0 };
    const pr = pin.getBoundingClientRect();
    const sx = pr.left - hr.left + pr.width / 2;
    const sy = pr.top  - hr.top  + pr.height / 2;

    const extra = 220;
    const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    const ex = isRight ? vw - hr.left + extra : -hr.left - extra;
    const ey = sy + (isRight ? yOffset : yOffset * 1.35);

    const dx = ex - sx;
    const cp1x = sx + dx * 0.42;
    const cp2x = sx + dx * 0.82;
    return `M${sx},${sy} C${cp1x},${sy} ${cp2x},${ey} ${ex},${ey}`;
  };

  const quad = (pin: HTMLElement, isRight: boolean, yOffset = -20) => {
    const hr = heroEl?.getBoundingClientRect() ?? { left:0, top:0, width:0, height:0, right:0 };
    const pr = pin.getBoundingClientRect();
    const sx = pr.left - hr.left + pr.width / 2;
    const sy = pr.top  - hr.top  + pr.height / 2;

    const extra = 300;
    const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    const ex = isRight ? vw - hr.left + extra : -hr.left - extra;
    const ey = sy + (isRight ? yOffset : -yOffset);
    const cp1x = sx + (ex - sx) * 0.60;
    return `M${sx},${sy} Q${cp1x},${sy} ${ex},${ey}`;
  };

  const updatePaths = () => {
    if (!heroEl || !svg) return;
    setSvgFrame();
    const rc = $("#hero-right-conn");
    const lc = $("#hero-left-conn");
    const rct = $("#hero-right-conn-top");
    const lct = $("#hero-left-conn-top");
    if (rp && rc)  rc.setAttribute("d",  bezier(rp, true));
    if (lp && lc)  lc.setAttribute("d",  bezier(lp, false, 80));
    if (rpt && rct) rct.setAttribute("d", quad(rpt, true));
    if (lpt && lct) lct.setAttribute("d", quad(lpt, false));
  };

  // Reveal on enter
  const revealEls = Array.from(document.querySelectorAll(".reveal"));
  const io: any = ("IntersectionObserver" in window) ? new IntersectionObserver((entries) => {
    for (const e of entries) if (e.isIntersecting) { e.target.classList.add("is-visible"); io.unobserve(e.target); }
  }, { rootMargin: "0px 0px -10% 0px", threshold: .15 }) : null;
  if (io) revealEls.forEach(el => io.observe(el)); else revealEls.forEach(el => el.classList.add("is-visible"));



  // Keep paths fresh
  const raf = (fn: FrameRequestCallback) => requestAnimationFrame(fn);
  addEventListener("resize", () => raf(updatePaths));
  addEventListener("load",   () => raf(updatePaths));
  setTimeout(() => raf(updatePaths), 50);

  if (window.ResizeObserver && heroEl) {
    const ro = new ResizeObserver(() => raf(updatePaths));
    ro.observe(heroEl);
  }
</script>
